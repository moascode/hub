# Spring Data

## Spring Data Questions

### 1. **How does Spring Data JPA simplify working with databases compared to traditional JPA?**

Spring Data JPA simplifies database operations by **abstracting away boilerplate code** like CRUD operations and transaction management. It provides interfaces like `JpaRepository` that automatically implement methods for basic database operations (e.g., save, find, delete). This eliminates the need to manually write common queries and code, and enables the use of **method name query generation**.

---

### 2. **What are the differences between `JpaRepository`, `CrudRepository`, and `PagingAndSortingRepository` in Spring Data?**

- **`CrudRepository`**: Basic CRUD operations (`save`, `findById`, `delete`).
- **`PagingAndSortingRepository`**: Extends `CrudRepository` and adds pagination and sorting features.
- **`JpaRepository`**: Extends both `CrudRepository` and `PagingAndSortingRepository` and adds additional features like **flush** and **batch processing**.

---

### 3. **How would you define a custom query in Spring Data JPA using the `@Query` annotation?**

You can use the `@Query` annotation to write custom queries. Example:

```java
@Query("SELECT u FROM User u WHERE u.email = ?1")
List<User> findByEmail(String email);
```

Here, `?1` refers to the first method parameter.

---

### 4. **What are the advantages of using Spring Data JPA over Hibernate directly?**

- **Less boilerplate**: Spring Data JPA generates repository interfaces and provides default implementations.
- **Integrated support**: Provides automatic transaction management and integrates seamlessly with Spring's other features (e.g., Spring Security).
- **Custom queries**: Easily define custom queries using `@Query` or method name conventions.
  
---

### 5. **Can you explain the role of `@Entity`, `@Table`, and `@Id` annotations in Spring Data JPA?**

- **`@Entity`**: Marks a class as a JPA entity, meaning it will be mapped to a database table.
- **`@Table`**: Specifies the name of the table in the database (optional if it follows naming conventions).
- **`@Id`**: Marks a field as the primary key for the entity.

---

### 6. **What are projections in Spring Data JPA, and how do they differ from entities?**

Projections in Spring Data JPA are **interfaces or classes** that define a subset of the entity's properties, useful for reducing data transfer overhead. Unlike entities, projections don’t map to complete rows in the database but to a portion of the entity.

Example:

```java
interface UserProjection {
    String getName();
    String getEmail();
}
```

---

### 7. **How do you handle complex joins and relationships (e.g., One-to-Many, Many-to-Many) in Spring Data JPA?**

Spring Data JPA supports complex relationships:

- **`@OneToMany`**, **`@ManyToOne`**, **`@ManyToMany`** to define relationships between entities.
- **`@Query`** can be used to create custom queries with joins.

Example:

```java
@OneToMany(mappedBy = "author")
private List<Book> books;
```

---

### 8. **How does Spring Data JPA automatically generate queries for common CRUD operations?**

Spring Data JPA generates queries based on method names by following naming conventions. For example:

- `findByName` generates a `SELECT * FROM table WHERE name = ?`
- `findByAgeGreaterThan` generates `SELECT * FROM table WHERE age > ?`

---

### 9. **Explain the use of `@Modifying` and `@Transactional` annotations in Spring Data JPA.**

- **`@Modifying`**: Indicates that the query modifies the database (e.g., `UPDATE`, `DELETE`).
- **`@Transactional`**: Ensures that the method is executed within a transactional context, i.e., operations are committed/rolled back atomically.

Example:

```java
@Transactional
@Modifying
@Query("UPDATE User u SET u.status = ?1 WHERE u.id = ?2")
int updateUserStatus(String status, Long id);
```

---

### 10. **What is the purpose of the `@Query` annotation in Spring Data JPA, and how can it be used for custom queries?**

The `@Query` annotation is used to define custom queries directly in the repository interface. You can use JPQL (Java Persistence Query Language) or native SQL:

```java
@Query("SELECT u FROM User u WHERE u.name = :name")
List<User> findByName(@Param("name") String name);
```

---

### 11. **What is the difference between `EntityManager` and `JpaRepository` in Spring Data JPA?**

- **`EntityManager`**: Provides low-level operations for managing entities in JPA (used for custom persistence logic).
- **`JpaRepository`**: A higher-level abstraction that provides default CRUD methods and supports custom queries with minimal boilerplate.

---

### 12. **Can you explain the concept of derived queries in Spring Data and give an example?**

**Derived queries** are automatically generated by Spring Data JPA based on method names. The method name defines the query's behavior.
Example:

```java
List<User> findByEmail(String email);
```

Spring Data JPA will generate the query `SELECT * FROM User WHERE email = ?`.

---

### 13. **What is the significance of query derivation in Spring Data repositories, and how does it work?**

Query derivation allows you to write methods with names that automatically translate into SQL queries. It saves you from writing boilerplate queries for simple operations.

Example:

```java
List<User> findByLastNameAndAgeGreaterThan(String lastName, int age);
```

Spring Data JPA generates the appropriate query based on the method name.

---

### 14. **How can you handle pagination and sorting with Spring Data JPA?**

Spring Data JPA supports pagination and sorting with `Pageable` and `Sort`:

```java
Page<User> findAll(Pageable pageable);
List<User> findAll(Sort sort);
```

`Pageable` allows you to define page size, number, and sort order.

---

### 15. **What is the difference between lazy loading and eager loading in Spring Data JPA?**

- **Lazy loading**: Related entities are loaded on-demand (e.g., when accessed).
- **Eager loading**: Related entities are loaded immediately with the parent entity.
In Spring Data JPA, the default fetching (loading) strategy is eager loading for @ManyToOne and @OneToOne relationships, and lazy loading for @OneToMany and @ManyToMany relationships.

Lazy loading can be enabled with `@OneToMany(fetch = FetchType.LAZY)`, while eager loading uses `@OneToMany(fetch = FetchType.EAGER)`.

---

### 16. **How would you implement a custom repository with complex queries in Spring Data JPA?**

You can implement custom repositories by creating a separate interface and class:

```java
public interface CustomUserRepository {
    List<User> findByCustomCriteria(String name, int age);
}
```

```java
public class CustomUserRepositoryImpl implements CustomUserRepository {
    @PersistenceContext
    private EntityManager entityManager;

    public List<User> findByCustomCriteria(String name, int age) {
        // custom query logic
    }
}
```

```java
public interface UserRepository extends JpaRepository<User, Long>, CustomUserRepository {}
```

---

### 17. **What are DTOs (Data Transfer Objects) in Spring Data JPA, and how are they different from entities?**

**DTOs** are used to transfer data between layers or systems, and often contain only the necessary fields (unlike entities which map to database tables). DTOs help reduce data transfer overhead and are not mapped to database tables.

---

### 18. **How would you perform bulk updates or deletes in Spring Data JPA?**

Bulk updates/deletes can be executed using `@Modifying` with custom queries:

```java
@Transactional
@Modifying
@Query("UPDATE User u SET u.status = ?1 WHERE u.id IN ?2")
int updateStatusForUsers(String status, List<Long> ids);
```

```java
@Transactional
@Modifying
@Query("DELETE FROM User u WHERE u.age < ?1")
int deleteByAgeLessThan(int age);
```

---

### 19. **What is the role of `@EntityListeners` in Spring Data JPA, and when should it be used?**

`@EntityListeners` is used to register callback methods (like `@PrePersist`, `@PostPersist`, `@PreUpdate`) that can perform actions before or after an entity’s lifecycle events (e.g., persist, update, delete). It is used for auditing, logging, or other custom logic.

---

### 20. **How can you handle cascading operations (e.g., persist, delete) in Spring Data JPA when dealing with entity relationships?**

Cascading operations can be handled using the `cascade` attribute in relationships:

```java
@OneToMany(cascade = CascadeType.ALL)
private List<Book> books;
```

This ensures that when the parent entity is saved or deleted, the related entities (e.g., `books`) will also be affected.

---

### **Bonus Question:**

- **How does Spring Data REST work and how can it be customized?**
Spring Data REST automatically exposes Spring Data repositories as RESTful APIs. It can be customized using the `@RepositoryRestResource` annotation and by adding custom controllers or security filters. You can also add `@RestResource(exported = false)` to disable certain endpoints.
